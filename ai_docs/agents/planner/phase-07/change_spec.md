# CHANGE SPEC — Phase 7: Launch Polish & Reliability

## 1) Title
Add launch polish: observability endpoints, user profiles, generation history, UX improvements, and SEO optimization.

## 2) Scope
- **Add**: Health/status endpoints, analytics tracking, profile settings, generation history with filters
- **Add**: Loading skeletons, error boundaries, empty states, SEO metadata 
- **Modify**: Existing services to add structured logging, enhance profile repository
- **NOT Touch**: Core generation flow, authentication, billing, or community features

## 3) Do-Not-Touch List (repeat from handbook §0)
- Keep these files intact:
  - app/layout.tsx, app/page.tsx, app/error.tsx, app/not-found.tsx
  - app/signin/**/*, app/dashboard/**/*, app/blog/**/*, app/privacy-policy/page.tsx, app/tos/page.tsx
  - app/api/auth/callback/route.ts
  - app/api/stripe/create-checkout/route.ts
  - app/api/stripe/create-portal/route.ts
  - app/api/webhook/stripe/route.ts
  - middleware.ts, config.ts, components/**/*, libs/**/*, types/**/*

## 4) File Operations (explicit)

### 4.1 Add

#### Migrations
- `migrations/phase7/011_logs_analytics.sql`
```sql
-- Analytics events table for first-party tracking
create table if not exists public.logs_analytics (
  id bigint generated by default as identity primary key,
  owner_id uuid,                 -- nullable for anonymous page views
  type text not null,
  payload jsonb,
  created_at timestamptz default now()
);
alter table public.logs_analytics enable row level security;

-- Anyone can insert their own events; nobody can select (admin-only later if needed)
create policy "analytics_insert" on public.logs_analytics for insert
  with check (auth.uid() = owner_id or owner_id is null);
create policy "analytics_no_select" on public.logs_analytics for select
  using (false);
```

- `migrations/phase7/012_profile_enhancements.sql`
```sql
-- Add profile settings fields
alter table public.profiles add column if not exists name text;
alter table public.profiles add column if not exists preferences jsonb default '{}'::jsonb;

-- Update existing RLS policies for new fields
create policy "profiles_self_select_enhanced"
on public.profiles for select
using (auth.uid() = id);

create policy "profiles_self_update_enhanced"  
on public.profiles for update
using (auth.uid() = id);
```

#### Observability Infrastructure
- `libs/observability/logger.ts`
```typescript
export const log = {
  info: (msg: string, meta?: any) => console.info(JSON.stringify({ lvl:'info', msg, ts: new Date().toISOString(), ...meta })),
  warn: (msg: string, meta?: any) => console.warn(JSON.stringify({ lvl:'warn', msg, ts: new Date().toISOString(), ...meta })),
  error: (msg: string, meta?: any) => console.error(JSON.stringify({ lvl:'error', msg, ts: new Date().toISOString(), ...meta })),
}
```

- `app/api/v1/health/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';

export async function GET(req: NextRequest) {
  return NextResponse.json({
    ok: true,
    time: new Date().toISOString(),
    versions: {
      next: process.env.npm_package_version || 'unknown'
    }
  });
}
```

- `app/api/v1/status/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createServiceSupabaseClient } from '@/libs/supabase/server';

export async function GET(req: NextRequest) {
  try {
    const supabase = createServiceSupabaseClient();
    // Test with a simple query
    const { error } = await supabase.from('profiles').select('id').limit(1);
    
    return NextResponse.json({
      supabase: error ? 'error' : 'ok'
    });
  } catch (error) {
    return NextResponse.json({
      supabase: 'error'
    });
  }
}
```

- `app/api/v1/analytics/event/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createServiceSupabaseClient } from '@/libs/supabase/server';
import { withMethods } from '@/libs/api-utils/methods';
import { validate } from '@/libs/api-utils/validate';
import { ok, fail } from '@/libs/api-utils/responses';

const EventSchema = z.object({
  type: z.enum(['page', 'generation_submit', 'generation_done', 'error']),
  payload: z.any().optional()
});

export async function POST(req: NextRequest) {
  return withMethods(['POST'], async () => {
    try {
      const body = await validate(req, EventSchema);
      const supabase = createServiceSupabaseClient();
      
      // Get user ID if authenticated, null if anonymous
      const { data: { user } } = await supabase.auth.getUser();
      
      const { error } = await supabase
        .from('logs_analytics')
        .insert({
          owner_id: user?.id || null,
          type: body.type,
          payload: body.payload || null
        });
        
      if (error) throw error;
      
      return ok({ message: 'Event logged' });
    } catch (error) {
      // Analytics should never block user experience
      console.warn('Analytics error:', error);
      return ok({ message: 'Event logged' }); // Always return success
    }
  });
}
```

#### Profile Settings
- `libs/services/profile.ts`
```typescript
import type { SupabaseClient } from '@supabase/supabase-js';
import { getProfileById, updateProfileSettings } from '@/libs/repositories/profiles';

export type ProfileSettings = {
  name?: string | null;
  preferences?: any;
};

export async function getProfileSettingsService(
  ctx: { supabase: SupabaseClient },
  args: { userId: string }
): Promise<ProfileSettings> {
  const profile = await getProfileById(ctx.supabase, args.userId);
  return {
    name: profile.name,
    preferences: profile.preferences || {}
  };
}

export async function updateProfileSettingsService(
  ctx: { supabase: SupabaseClient },
  args: { userId: string; settings: ProfileSettings }
): Promise<ProfileSettings> {
  await updateProfileSettings(ctx.supabase, args.userId, args.settings);
  return await getProfileSettingsService(ctx, { userId: args.userId });
}
```

- `app/api/v1/profile/settings/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createServiceSupabaseClient } from '@/libs/supabase/server';
import { withMethods } from '@/libs/api-utils/methods';
import { validate } from '@/libs/api-utils/validate';
import { ok, fail } from '@/libs/api-utils/responses';
import { getProfileSettingsService, updateProfileSettingsService } from '@/libs/services/profile';

const UpdateSettingsSchema = z.object({
  name: z.string().optional(),
  preferences: z.any().optional()
});

export async function GET(req: NextRequest) {
  return withMethods(['GET'], async () => {
    try {
      const supabase = createServiceSupabaseClient();
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return fail('UNAUTHORIZED', 'Authentication required');
      }
      
      const settings = await getProfileSettingsService(
        { supabase },
        { userId: user.id }
      );
      
      return ok(settings);
    } catch (error) {
      return fail('INTERNAL_ERROR', 'Failed to get profile settings');
    }
  });
}

export async function PATCH(req: NextRequest) {
  return withMethods(['PATCH'], async () => {
    try {
      const body = await validate(req, UpdateSettingsSchema);
      const supabase = createServiceSupabaseClient();
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return fail('UNAUTHORIZED', 'Authentication required');
      }
      
      const settings = await updateProfileSettingsService(
        { supabase },
        { userId: user.id, settings: body }
      );
      
      return ok(settings);
    } catch (error) {
      return fail('INTERNAL_ERROR', 'Failed to update profile settings');
    }
  });
}
```

#### Generation History
- `app/api/v1/generations/history/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createServiceSupabaseClient } from '@/libs/supabase/server';
import { withMethods } from '@/libs/api-utils/methods';
import { ok, fail } from '@/libs/api-utils/responses';
import { getGenerationHistoryService } from '@/libs/services/generations';

export async function GET(req: NextRequest) {
  return withMethods(['GET'], async () => {
    try {
      const supabase = createServiceSupabaseClient();
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        return fail('UNAUTHORIZED', 'Authentication required');
      }
      
      const { searchParams } = new URL(req.url);
      const filters = {
        cursor: searchParams.get('cursor') || undefined,
        limit: parseInt(searchParams.get('limit') || '24'),
        mode: searchParams.get('mode') || undefined,
        roomType: searchParams.get('roomType') || undefined,
        style: searchParams.get('style') || undefined,
        status: searchParams.get('status') || undefined
      };
      
      const history = await getGenerationHistoryService(
        { supabase },
        { userId: user.id, filters }
      );
      
      return ok(history);
    } catch (error) {
      return fail('INTERNAL_ERROR', 'Failed to get generation history');
    }
  });
}
```

#### UI Components  
- `components/ui/skeleton.tsx`
```typescript
import { cn } from "@/libs/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
```

- `components/ErrorBoundary.tsx`
```typescript
'use client';

import React from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<{ error?: Error; reset: () => void }>;
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return (
        <FallbackComponent 
          error={this.state.error} 
          reset={() => this.setState({ hasError: false })} 
        />
      );
    }

    return this.props.children;
  }
}

function DefaultErrorFallback({ error, reset }: { error?: Error; reset: () => void }) {
  return (
    <div className="flex flex-col items-center justify-center min-h-[200px] text-center">
      <h2 className="text-lg font-semibold mb-2">Something went wrong</h2>
      <p className="text-muted-foreground mb-4">
        {error?.message || 'An unexpected error occurred'}
      </p>
      <button
        onClick={reset}
        className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90"
      >
        Try again
      </button>
    </div>
  );
}
```

- `app/(app)/dashboard/profile/page.tsx`
```typescript
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Skeleton } from '@/components/ui/skeleton';

export default function ProfilePage() {
  const [profile, setProfile] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [name, setName] = useState('');

  useEffect(() => {
    fetchProfile();
  }, []);

  const fetchProfile = async () => {
    try {
      const response = await fetch('/api/v1/profile/settings');
      const data = await response.json();
      
      if (data.success) {
        setProfile(data.data);
        setName(data.data.name || '');
      }
    } catch (error) {
      console.error('Failed to fetch profile:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    setSaving(true);
    try {
      const response = await fetch('/api/v1/profile/settings', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      });
      
      const data = await response.json();
      if (data.success) {
        setProfile(data.data);
      }
    } catch (error) {
      console.error('Failed to save profile:', error);
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <Skeleton className="h-6 w-32" />
        </CardHeader>
        <CardContent className="space-y-4">
          <Skeleton className="h-10 w-full" />
          <Skeleton className="h-10 w-24" />
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Profile Settings</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div>
          <Label htmlFor="name">Display Name</Label>
          <Input
            id="name"
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder="Enter your name"
          />
        </div>
        <Button onClick={handleSave} disabled={saving}>
          {saving ? 'Saving...' : 'Save Changes'}
        </Button>
      </CardContent>
    </Card>
  );
}
```

- `app/(app)/dashboard/history/page.tsx`
```typescript
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { Badge } from '@/components/ui/badge';

export default function HistoryPage() {
  const [history, setHistory] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [filters, setFilters] = useState({
    mode: '',
    roomType: '',
    style: '',
    status: ''
  });

  useEffect(() => {
    fetchHistory();
  }, [filters]);

  const fetchHistory = async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      Object.entries(filters).forEach(([key, value]) => {
        if (value) params.append(key, value);
      });
      
      const response = await fetch(`/api/v1/generations/history?${params}`);
      const data = await response.json();
      
      if (data.success) {
        setHistory(data.data.items || []);
      }
    } catch (error) {
      console.error('Failed to fetch history:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="space-y-4">
        <Card>
          <CardHeader>
            <Skeleton className="h-6 w-48" />
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {Array.from({ length: 6 }).map((_, i) => (
                <Skeleton key={i} className="h-48 w-full" />
              ))}
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Generation History</CardTitle>
      </CardHeader>
      <CardContent>
        {history.length === 0 ? (
          <div className="text-center py-8">
            <p className="text-muted-foreground mb-4">No generations yet</p>
            <a href="/dashboard/generate" className="text-primary hover:underline">
              Create your first design
            </a>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {history.map((item: any) => (
              <Card key={item.id} className="overflow-hidden">
                <CardContent className="p-4">
                  <div className="flex items-center justify-between mb-2">
                    <Badge variant="outline">{item.mode}</Badge>
                    <Badge variant={item.status === 'succeeded' ? 'default' : 'destructive'}>
                      {item.status}
                    </Badge>
                  </div>
                  <p className="text-sm text-muted-foreground">
                    {item.roomType} • {item.style}
                  </p>
                  <p className="text-xs text-muted-foreground mt-1">
                    {new Date(item.createdAt).toLocaleDateString()}
                  </p>
                </CardContent>
              </Card>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```

### 4.2 Modify

#### Repository Enhancements
- `libs/repositories/profiles.ts`
```typescript
// Add to existing file after line 60:

export type ProfileSettings = {
  name?: string | null;
  preferences?: any;
};

// UPDATE: profile settings
export async function updateProfileSettings(
  db: SupabaseClient,
  userId: string,
  settings: ProfileSettings
) {
  const updates: any = {};
  if (settings.name !== undefined) updates.name = settings.name;
  if (settings.preferences !== undefined) updates.preferences = settings.preferences;
  
  const { error } = await db
    .from("profiles")
    .update(updates)
    .eq("id", userId);
  if (error) throw error;
}
```

- `libs/repositories/generations.ts`
```typescript
// Add to existing file:

export async function getGenerationHistory(
  db: SupabaseClient,
  params: {
    userId: string;
    cursor?: string;
    limit?: number;
    mode?: string;
    roomType?: string;
    style?: string;
    status?: string;
  }
) {
  let query = db
    .from('generation_jobs')
    .select(`
      id,
      status,
      mode,
      room_type,
      style,
      created_at,
      completed_at,
      error
    `)
    .eq('owner_id', params.userId)
    .order('created_at', { ascending: false });

  if (params.mode) query = query.eq('mode', params.mode);
  if (params.roomType) query = query.eq('room_type', params.roomType);
  if (params.style) query = query.eq('style', params.style);
  if (params.status) query = query.eq('status', params.status);
  if (params.limit) query = query.limit(params.limit);
  
  const { data, error } = await query;
  if (error) throw error;
  
  return data || [];
}
```

#### Service Enhancements  
- `libs/services/generations.ts`
```typescript
// Add to existing file:

import { log } from '@/libs/observability/logger';
import { getGenerationHistory } from '@/libs/repositories/generations';

// Add to existing submitGeneration function, after line where job is created:
log.info('Generation submitted', { 
  jobId: job.id, 
  userId: args.userId, 
  mode: args.mode,
  predictionId: job.prediction_id 
});

// Add to existing getGeneration function polling logic:
log.info('Generation status check', { 
  jobId: args.id, 
  status: job.status,
  predictionId: job.prediction_id 
});

// Add new function:
export async function getGenerationHistoryService(
  ctx: { supabase: SupabaseClient },
  args: { userId: string; filters: any }
) {
  const items = await getGenerationHistory(ctx.supabase, {
    userId: args.userId,
    ...args.filters
  });
  
  return {
    items,
    nextCursor: items.length === (args.filters.limit || 24) ? 'more' : null
  };
}
```

- `libs/services/replicate.ts`
```typescript
// Add to existing file, in createPrediction function after Replicate call:

import { log } from '@/libs/observability/logger';

// After successful prediction creation:
log.info('Replicate prediction created', {
  predictionId: prediction.id,
  model: 'openai/gpt-image-1',
  status: prediction.status
});

// In error handling:
log.error('Replicate prediction failed', {
  error: error.message,
  model: 'openai/gpt-image-1'
});
```

#### Repository Files
- `libs/repositories/analytics.ts`
```typescript
import type { SupabaseClient } from "@supabase/supabase-js";

export type AnalyticsEvent = {
  id: string;
  owner_id: string | null;
  type: string;
  payload: any;
  created_at: string;
};

export async function createAnalyticsEvent(
  db: SupabaseClient,
  params: {
    ownerId?: string | null;
    type: string;
    payload?: any;
  }
) {
  const { error } = await db
    .from("logs_analytics")
    .insert({
      owner_id: params.ownerId,
      type: params.type,
      payload: params.payload || null
    });
  if (error) throw error;
}
```

## 5) Implementation Notes
- All new endpoints follow Route → Service → Repository pattern
- Validation with Zod in route handlers using existing helpers
- Use `createServiceSupabaseClient()` for non-admin operations
- Analytics is fire-and-forget; failures don't block user experience
- Structured logging uses JSON format to stdout for easy parsing
- Error boundaries catch React errors; API errors handled in existing pattern
- Loading skeletons prevent layout shifts; use existing design tokens

## 6) Post‑Apply Checks (agent must run)
1. `npm run build` passes without errors
2. New health endpoints return expected JSON:
   - `curl /api/v1/health` → `{ ok: true, time: "...", versions: {...} }`
   - `curl /api/v1/status` → `{ supabase: "ok" }`
3. Grep checks (must return 0):
   - `grep -R "use server" app libs` → 0
   - `grep -R "createServerClient" components` → 0  
   - `grep -R "service_role" app components` → 0
4. Profile settings endpoints work with authenticated requests
5. Generation history endpoint returns paginated results
6. Analytics events can be posted without errors
7. Dashboard pages load with proper error boundaries and skeletons

## 7) Rollback Plan
- Remove all added files listed in section 4.1
- Revert modified files to their previous state
- Drop database tables: `DROP TABLE logs_analytics;`
- Remove added columns: `ALTER TABLE profiles DROP COLUMN name, DROP COLUMN preferences;`
- Confirm `npm run build` passes and existing functionality works