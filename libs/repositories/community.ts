import type { SupabaseClient } from '@supabase/supabase-js'

export interface CommunityCollection {
  id: string
  title: string
  description?: string
  is_featured: boolean
  order_index: number
  created_at: string
}

export interface CommunityItem {
  id: string
  collection_id: string
  render_id?: string
  external_image_url?: string
  apply_settings?: any
  order_index: number
  created_at: string
}

export interface CommunityItemWithRender {
  id: string
  collection_id: string
  render_id?: string
  external_image_url?: string
  apply_settings?: any
  order_index: number
  created_at: string
  render?: {
    id: string
    mode: string
    room_type?: string
    style?: string
    cover_variant: number
    created_at: string
    cover_image_url: string
  }
}

export async function listCommunityCollections(
  supabase: SupabaseClient,
  featuredOnly = false
): Promise<CommunityCollection[]> {
  let query = supabase
    .from('community_collections')
    .select('*')
    .order('is_featured', { ascending: false })
    .order('order_index', { ascending: true })
    .order('created_at', { ascending: false })

  if (featuredOnly) {
    query = query.eq('is_featured', true)
  }

  const { data, error } = await query
  if (error) throw error
  
  return data || []
}

export async function getCommunityCollection(
  supabase: SupabaseClient,
  collectionId: string
): Promise<CommunityCollection | null> {
  const { data, error } = await supabase
    .from('community_collections')
    .select('*')
    .eq('id', collectionId)
    .single()

  if (error && error.code !== 'PGRST116') throw error
  return data || null
}

export async function listCommunityItems(
  supabase: SupabaseClient,
  collectionId: string,
  limit = 50
): Promise<CommunityItemWithRender[]> {
  const { data, error } = await supabase
    .from('community_items')
    .select(`
      id,
      collection_id,
      render_id,
      external_image_url,
      apply_settings,
      order_index,
      created_at,
      renders:render_id (
        id,
        mode,
        room_type,
        style,
        cover_variant,
        created_at
      )
    `)
    .eq('collection_id', collectionId)
    .order('order_index', { ascending: true })
    .order('created_at', { ascending: false })
    .limit(limit)

  if (error) throw error

  // Format the response
  const formattedItems: CommunityItemWithRender[] = (data || []).map(item => {
    const result: CommunityItemWithRender = {
      id: item.id,
      collection_id: item.collection_id,
      render_id: item.render_id,
      external_image_url: item.external_image_url,
      apply_settings: item.apply_settings,
      order_index: item.order_index,
      created_at: item.created_at
    }

    // Add render data if available
    if (item.renders && item.render_id) {
      const renderData = Array.isArray(item.renders) ? item.renders[0] : item.renders
      result.render = {
        id: renderData.id,
        mode: renderData.mode,
        room_type: renderData.room_type,
        style: renderData.style,
        cover_variant: renderData.cover_variant,
        created_at: renderData.created_at,
        cover_image_url: null // Should be generated by storage service
      }
    }

    return result
  })

  return formattedItems
}

export async function getCommunityCollectionWithItems(
  supabase: SupabaseClient,
  collectionId: string
): Promise<{
  collection: CommunityCollection
  items: CommunityItemWithRender[]
} | null> {
  const collection = await getCommunityCollection(supabase, collectionId)
  
  if (!collection) {
    return null
  }

  const items = await listCommunityItems(supabase, collectionId)

  return {
    collection,
    items
  }
}

export async function getAllCommunityCollectionsWithItems(
  supabase: SupabaseClient,
  featuredOnly = false,
  itemsPerCollection = 10
): Promise<Array<{
  collection: CommunityCollection
  items: CommunityItemWithRender[]
}>> {
  const collections = await listCommunityCollections(supabase, featuredOnly)

  const collectionsWithItems = await Promise.all(
    collections.map(async (collection) => {
      const items = await listCommunityItems(supabase, collection.id, itemsPerCollection)
      return {
        collection,
        items
      }
    })
  )

  return collectionsWithItems
}

export async function searchCommunityItems(
  supabase: SupabaseClient,
  query: string,
  limit = 20
): Promise<CommunityItemWithRender[]> {
  // Search in apply_settings for matching terms
  // This is a simplified search - in production you might use full-text search
  const { data, error } = await supabase
    .from('community_items')
    .select(`
      id,
      collection_id,
      render_id,
      external_image_url,
      apply_settings,
      order_index,
      created_at,
      renders:render_id (
        id,
        mode,
        room_type,
        style,
        cover_variant,
        created_at
      )
    `)
    .or(`apply_settings->>'style'.ilike.%${query}%,apply_settings->>'roomType'.ilike.%${query}%,apply_settings->>'prompt'.ilike.%${query}%`)
    .limit(limit)

  if (error) throw error

  // Format the response (similar to listCommunityItems)
  const formattedItems: CommunityItemWithRender[] = (data || []).map(item => {
    const result: CommunityItemWithRender = {
      id: item.id,
      collection_id: item.collection_id,
      render_id: item.render_id,
      external_image_url: item.external_image_url,
      apply_settings: item.apply_settings,
      order_index: item.order_index,
      created_at: item.created_at
    }

    if (item.renders && item.render_id) {
      const renderData = Array.isArray(item.renders) ? item.renders[0] : item.renders
      result.render = {
        id: renderData.id,
        mode: renderData.mode,
        room_type: renderData.room_type,
        style: renderData.style,
        cover_variant: renderData.cover_variant,
        created_at: renderData.created_at,
        cover_image_url: null // Should be generated by storage service
      }
    }

    return result
  })

  return formattedItems
}

// Admin functions (for future admin interface)
export async function createCommunityCollection(
  supabase: SupabaseClient,
  collection: Omit<CommunityCollection, 'id' | 'created_at'>
): Promise<CommunityCollection> {
  const { data, error } = await supabase
    .from('community_collections')
    .insert(collection)
    .select()
    .single()

  if (error) throw error
  return data
}

export async function updateCommunityCollection(
  supabase: SupabaseClient,
  collectionId: string,
  updates: Partial<Omit<CommunityCollection, 'id' | 'created_at'>>
): Promise<void> {
  const { error } = await supabase
    .from('community_collections')
    .update(updates)
    .eq('id', collectionId)

  if (error) throw error
}

export async function createCommunityItem(
  supabase: SupabaseClient,
  item: Omit<CommunityItem, 'id' | 'created_at'>
): Promise<CommunityItem> {
  const { data, error } = await supabase
    .from('community_items')
    .insert(item)
    .select()
    .single()

  if (error) throw error
  return data
}

export async function updateCommunityItem(
  supabase: SupabaseClient,
  itemId: string,
  updates: Partial<Omit<CommunityItem, 'id' | 'created_at'>>
): Promise<void> {
  const { error } = await supabase
    .from('community_items')
    .update(updates)
    .eq('id', itemId)

  if (error) throw error
}

export async function deleteCommunityItem(
  supabase: SupabaseClient,
  itemId: string
): Promise<void> {
  const { error } = await supabase
    .from('community_items')
    .delete()
    .eq('id', itemId)

  if (error) throw error
}